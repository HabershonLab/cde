\subsection*{$\ast$$\ast$\+Introduction$\ast$$\ast$}

This section gives example input files and instructions for a simple Graph\+Gen calculation run through C\+DE. The overal aim of this algorithm is to aid the analysis of the resulting reaction paths and molecules generated by G\+DS, with the intention of discovering how to generate reaction pathways involving multiple competing reaction paths that might take us from one molecule to another within the G\+DS network oF reactions. By selecting the particular reactants and products the user whishes to analyse, the program then provides the most plausible pathways (given all the information gathered during G\+DS) that connect these, and therefore suggest to the user which reaction paths generated by G\+DS are actually worth calculating their barrier for (using N\+EB), the most expensive procedure of C\+DE. The G\+DS algorithm is able to generate a Molecular Database by setting {\bfseries moldata} = .true. in the input structure. This database contains a list of all Molecules and their respective reactions that were found during the G\+DS procedure. Note that {\bfseries optaftermove} and {\bfseries skiprepeats} keywords {\itshape will} automatically be switched on when setting moldata true. This database is then used to construct the reaction network from which Graph\+Gen will discover the most plausible pathways from the reactants the user provides, to the products she also provides, within this network. The algorithm has several stages A)\+:
\begin{DoxyItemize}
\item 1) It switches on all molecules that can be accessed via some reaction from the user-\/provided-\/reactants, forming a contected network which hopefully (should) have the products of interest. A graphviz file input-\/filename\$\+\_\+fullnet.\+gv and its postscript output are generated to display the full connected network.
\item 2) It traverses the network (depth-\/first search) throught the reaction edges and starting from the {\itshape products} to provide {\itshape directed} edges that have been found. A graphviz file \$input-\/filename\$\+\_\+untrimmednet.\+gv displays this network
\item 3) It trimms the nodes and directed edges of the network to remove any reactions and molecules that cannot in some way reach some of the reactants (from the products), as well as removing loops that lead nowhere. The trimmed network is written into \$input-\/filename\$\+\_\+directednet.\+gv.
\item 4) Starting from a user provided product-\/node at a time, it finds all possible reaction trees (under certain user-\/provided constraints explained below), with the root as the product in question, and reactants as \char`\"{}leafs R\char`\"{}, branching via single reaction steps that are available in the Mol.\+dat databse (the intermediates that every reaction produces form the branches of the trees). It does this by performing a depth-\/first search, not repeating nodes or reactions along each single root-\/to-\/leaf history (and storing the history of reactions and nodes, call it H), and then systematically accummulate the possible branches that can be produced as it retreats from succesully found pathways to \char`\"{}leafs R\char`\"{}. It is worth noting that a given intermediate molecule X can have multiple R reactions, each reaction generating C molecules which themselves have many reactive branches (so on until we reach a leaf reactant) which need to be combined in all ways to obtain the total number of branches coming out of Reaction R. All branches from all reactions in molecule X have to be added together to form the sum total of plausible trees that can be built from this choice of X (provided the current history of visited nodes and reaction H during the depth-\/first seach proccess).
\item 5) The reaction tree graphs obtained are subsequently {\itshape re-\/merged} wherever a reaction, for example A + B -\/$>$ C + D, appears twice in a tree with nodes A and B having {\itshape identical} branches (all the way to \char`\"{}leafs R\char`\"{}) coming out of their C and D branches. This assumes that the exact same molecules that the reaction produced come together later to react futher to lead to the product. This may not always be the case, but its we will assume always the most efficient mechanism possible for each tree (the user can later decide it, for the particular problem at hand, it is likely). Strictly speaking, this makes the tree graphs no longer \char`\"{}trees\char`\"{}, but we shall continue to call them like such henceforth.
\end{DoxyItemize}

For each branching path history from the root to some \char`\"{}leaf R\char`\"{}, the trees generated cannot repeat nodes or reactions. Note that we dont mean that reactions or nodes cannot repeat in a tree, but that starting from the root and travelling to any leaf, one will not find a node/reaction being repeated. Nodes and reaction might be repeated in different branches {\itshape after they have branched out} (so that they dont share that node/reaction as a common root branch) .

Since we donnot know the barrier height of any of the reactions (not calculated by G\+DS, but by N\+EB), the fitness of each tree graph is estimated by the total (absoute) energy change between the intermediate reactants and its intermediate products, ie the reaction energy change, for all reactions in the tree. For merged branches, we donnot double count them.

Given a collection of all possible {\itshape branches} (sub-\/trees) coming out of some intermediate molecule, we will classify these into {\itshape clusters} or {\itshape families} of sub-\/trees (branches) that have similar graph structure and relative energies for the intermediates molecules of their branches. This can be achieved as follows B)\+:
\begin{DoxyItemize}
\item 1) define for each sub-\/tree (branch) a vector with dimensions of the total number of molecules found in the network described in A3) above.
\item 2) The elements of this vector represent a molecule intermediate. The value of that element is equal to the relative reaction path energy (starting from the product) that intermediate has on that tree. Each tree therefore has a vector which characterises the content of intermediates, and the relative energies of these in that tree.
\item 3) Let the mean tree vector of the set of N trees be called {\itshape t}.
\item 4) The M dimensional vectors of every tree, with the mean {\itshape t} subtracted from it, in the set N can then be put into and (N,M) matrix D. Let the covariant matrix of this data be C = D$^\wedge$T D
\item 5) The eigenvectors and eigenvalues of C then characterise different classes of trees within the set.
\item 6) Each tree is then associated with the eigenvector to which it contribuites the most.
\item 7) Trees are then clustered into these eigenvectors (provided and ev cluster ID).
\end{DoxyItemize}

Once the number of molecules and reactions exceed $\sim$50, the number of possible reaction trees that can be produced at every branching generation of part A4) of the algorithm becomes combinatorially (exponentially) large. Most of these trees will be of little interest, involving many convoluted pathways with too much energy change that will likely not be the more efficient way to generate the products. Consecuently, during the evaluation of branches of different generations when construcuting the trees, only the top {\bfseries maxtreepergen} trees of the children are kept to pass on to the parent branch, as the depth-\/first search accumulates trees as it climbs back (receeds) up the path. What constitutes the top {\bfseries maxtreepergen} trees is a somewhat ambiguous decision. Since we donnot know the barrier height of each reaction, it would be careless to merely select those by their fitness as defined in the previous parragraph. Instead, we also wish to pass on a collection of \textquotesingle{}diverse\textquotesingle{} trees that are representative of the types of trees found through that node molecule. We therefore pass the top 5\% of the most fit trees and the rest are a proportionate number of the most fit trees coming from every cluster family of trees.

Similarly, as the size of the network increases, actually traversing depth-\/first search through all possible pathway becomes expensive. Consequently, another threshold {\bfseries treegencutoff} is used. As we traverse the network, we count the number of node intermediate molecule has more than 1 reaction out of it, if these exceed {\bfseries treegencutoff} the search halts and it is assumed no important paths are obtained via it. For mechanisms that might involve only a few steps, {\bfseries treegencutoff} $\sim$10 should easily suffice. If the pathway involves a large number of steps, then {\bfseries treegencutoff} of 15-\/20 should be used. Beyond 20, typically the procedure become prohibitivley expensive. Finally, we also limit the maximum total energy change, a internal variable mxabsench, the the depth-\/first search accumulates at it travels; The total number of nodes the depth-\/first search visits is calculated, call it M. The program then adjusts {\bfseries mxabsench} such that the depth-\/first search visits makes M below 10$^\wedge$( {\bfseries mxndexplore} ), where the exponent {\bfseries mxndexplore} is a user adjusted parameter. This parameter substatially determines the time it takes for the algorithm to run -\/ a small number (will take seconds or minutes to finish) is 5 or 6. If 9 is chosen, with large {\bfseries treegencutoff}, expect to wait days (and would recomment using {\bfseries treediskstore} $\sim$ 0.\+15 if using large {\bfseries maxtreepergen}).

\subsection*{$\ast$$\ast$\+Example\+: C\+O2 catalysis on Pt9 clusters$\ast$$\ast$}

{\bfseries The actual files to run this example can be found in the $\ast$$\sim$/cde/examples/graphgen/$\ast$ directory.}

We will investigate how carbon monoxide and oxygen can be catalysed into carbon dioxide by the presence of a Platinum 9 cluster.

In this directory, you will find three input files\+: \begin{DoxyVerb}  input
  input_Mol.bin
  input_Mol.dat
\end{DoxyVerb}


The \char`\"{}input\+\_\+\+Mol\char`\"{} files would have been generated by a G\+DS run, that also produced reaction paths labelled \char`\"{}input\+\_\+00000\+X\+X.\+xyz\char`\"{}, which have been ommited in the directory for clarity. The \char`\"{}input\+\_\+\+Mol.\+dat\char`\"{} file is only used for the user to identify the molecule and reaction I\+Ds needed to specify the input keywords in the input file \char`\"{}input\char`\"{}. The input file must begin by setting the calculation type to {\bfseries graphgen}\+: \begin{DoxyVerb}#  Set the graphgen calculation
calctype graphgen
\end{DoxyVerb}


The Mol.\+bin and Mol.\+dat would have been generated by G\+DS. Inspecting the Mol.\+dat file, we will find the molecules are ordered by size and weight, with the biggest at the top of the file. We can then find near the bottom of the file\+: \begin{DoxyVerb}RANK :  71, Molecule   9 - O2C1 ( -0.654057 au)
#-----------------------------------------------------------
#          Reaction ID :  #React/Prod  :  Reactive Molecules 
                 4     :      2  1     :    8-Pt9O1 ( -1.477749),    9-O2C1 ( -0.654057)  <--->    7-Pt9O3C1 ( -2.126420)
                 5     :      2  2     :   10-Pt9O2C1 ( -1.696035),    9-O2C1 ( -0.654057)  <--->    4-Pt9O3C1 ( -2.139881),    5-O1C1 ( -0.414928)
                 7     :      1  2     :   10-Pt9O2C1 ( -1.696035)  <--->    1-Pt9 ( -1.326515),    9-O2C1 ( -0.654057)
                                                .
                                                .
                                                .
#          Reaction ID :  Degeneracy   :  ChemReactListID (direction) 
                 4     :      2        :    4 (->),   34 (->)
                 5     :      1        :    5 (->)
                 7     :      1        :    7 (->)
                 8     :      1        :    8 (->)
                 9     :      2        :    9 (->),   16 (<-)
\end{DoxyVerb}


Which shows that carbon dioxide \char`\"{}\+O2\+C1\char`\"{} has been indexed as molecule 9. Similarly we will find that \char`\"{}\+O1\+C1\char`\"{} has been identified as 5, \char`\"{}\+O2\char`\"{} as 2 and \char`\"{}\+Pt9\char`\"{} as 1. The first table prints every possible reaction this molecule has been identified in G\+DS, it has an ID, it says how many Product/\+Reactants it has, and then it prints the reaction with the molecular formula and ID (preceeding it by a hyphen, e.\+g. 8-\/\+Pt9\+P\+O1) of the reactants/products. The next table relates the Reaction ID with the ID of those reaction paths found in the Chem\+React\+List\+I\+D.\+info file produced during the G\+DS procedure that involve those reactants/products (many reaction paths found by G\+DS have the same reactants/products involved, but have a different orientation or mechanism), together with the orientation ($<$-\/, means that in Chem\+React\+List\+I\+D.\+info the products are the reactants).

The input file thus reads\+: \begin{DoxyVerb}#  The three reactants shown here correspond to Pt9 O2 and C1O1 as shown in input_Mol.dat
treereactants 3
1 2 5

#  We are only interested in finding how to O2C1 (carbon dioxide) is formed
treeproducts 1
9 
\end{DoxyVerb}


{\itshape caveat} The current implementation does not allow for the same molecule to be in {\bfseries treereactants} and {\bfseries treeproducts}. If some moiety is left attached in Pt9 at the end of the calculation, we can perform a second calculation to obtain graphs with Pt9 (index 1) as the product. Also important to note is that if we provide more than one product (not in this example) then the trees obtained {\itshape will not contain the other product as an intermediate}. If one wishes to find trees with one product as the intermediate of the other (that potentially might be relevat), then the user should run two calculations with 1 prouct at a time and then deduce how to then get both from the reactants by connecting their respective best trees.

We can see that the Database in Mol.\+dat has a reaction indexed 103\+: \char`\"{}71-\/\+O3\+C1 ( -\/0.\+642184)  $<$-\/-\/-\/$>$    2-\/\+O2 ( -\/0.\+205752),    5-\/\+O1\+C1 ( -\/0.\+414928)\char`\"{}, which productes carbon trioxide without a Platinum present. We know that is not an important and plausible reaction intermediate, so we can remove it from the network\+: \begin{DoxyVerb}#  This input_Mol.data has a reaction which does not involve Pt9, so we want to ignore it
ignorereac 1
103
\end{DoxyVerb}


A similar keyword for removing particular intermediates can be used {\bfseries ignoremol}, with similar syntax. Note that this just means that these molecules will not be active intermediates on the way to generating the products -\/ they will still appear as byproducts in reactions. But any reactions that generate that use that molecule on the way to the product will be switched off.

There will also exist reaction pathways that involve only two O1\+C1 forming O2\+C1 via Pt9, without 2O. We will therefore wish to disregard those reaction trees that donnot contain {\itshape all} reactants demanded by the {\bfseries treereactants} keyword, via\+: \begin{DoxyVerb}# Enforces to print only trees with full set of reactants as leafs
enforcefullrx .true.
\end{DoxyVerb}


{\itshape caveat} unfortunately, under the current implementation, it is not possible to discriminate which trees will have or not the full set of reactants until the end of procedure A4) (when all the branches are finally combined with the root product), which means that many trees with fewer than all the reactants in the set will be competing for survival in the set of final trees. Consecuently, to avoid not including the best variety of full-\/reaction-\/set trees, we recommend to use a genearous value for {\bfseries maxtreepergen} $>$ 2000, when used in conjunction with {\bfseries enforcefullrx}, to ensure that we crop sufficient full-\/reaction-\/set branches during the selection criteria.

Similarly, we can also request to only print trees whose sum of the relative energies of the reactants leafs is positive, negative or neutral. This can be achieved via the key {\bfseries treefaven}. For favourable reactions, set {\bfseries treefaven} to 1, unfavourable to -\/1 and neutral to 0. For this particular example, we wish to find the favourable reaction trees leading to O2\+C1\+: \begin{DoxyVerb}#  Enforces to print only those trees whose sum of all reactant leaves relative energies are positive (the reaction path is favourable)
treefaven 1
\end{DoxyVerb}


{\itshape caveat} similar to {\bfseries enforcefullrx}, this procedure is only performed at the end of the search (we cannot a priori tell what the overall sum of the leafs will be before we have put the entire tree together), so be sure to give a generous value for {\bfseries maxtreepergen}.

For both {\bfseries enforcefullrx} {\bfseries enforcefullrx}, if there are few trees in total, the routine might end up printing trees that violate these rules (since there might not be {\bfseries maxtreesolutions} of them to print out). In those instances the fitness in the btrees.\+dat file will be printed as $\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$ For this particular example, most of the unfavourable reactions are those that donnot involve the oxygen molecue, which are already screened out by {\bfseries enforcefullrx}.

Finally, we need to set parameters that determine the scope of the graph search. As aforementioned, {\bfseries maxtreepergen} determines how many of the best sub-\/trees (or branches) that a particular intermediate node collects from all the possible combinations of branches of its children branches. For this small system, the number if immaterial\+: \begin{DoxyVerb}#  From all child products trees of a particular molecule, collect the 500 best of each generation... (in this example, there are few trees anyway, so its not important)
maxtreepergen 500
\end{DoxyVerb}


For more challenging problems, one may wish to use larger figures, e. g. 500 $<$ {\bfseries maxtreepergen} $<$ 50000. Note that the more we store, the more memory is required to save these branches while we combine them at different generations. If the computer starts to struggle with memory issues, it is possible to store the temporary branches in disk. To this end we can write\+: \begin{DoxyVerb}#  If a child molecule has found 0.8*100 = 80 trees or more, then store these in disk (not really necessary here, but considere usefull when maxtreepergen > 5000)
treediskstore 0.8
\end{DoxyVerb}


If a particular node has more than 80\% of maxtreepergen sub-\/trees, then the program will store them in disk. Beware that a small values lead to lots of writing to disk which substantially slows down the calculation. As explained above {\bfseries treegencutoff} determines the maximum of branches-\/away-\/from-\/the-\/root for a tree, for branches that have more than one reactant available\+: \begin{DoxyVerb}#  Trees with more than 10 branches away from the root are dissmissed
treegencutoff 10
\end{DoxyVerb}


For this example, where the formation of O2\+C1 should take few steps, no more than 10 is more than sufficient. For more complicated products, one may wish to use up to 20. If one wishes to use more than this, be aware that the calculation may take considerably longer, and one may wish to keep {\bfseries mxndexplore} at a modest number ($<$8). As we have mentioned before {\bfseries mxndexplore} is the order of magnitute of a measure of the {\itshape breadth} of the search (the total number of nodes visited during the depth-\/first search). In general, this is arguably the parameter that determines the time taken to explore the network. In general, anything above 9 can be expected to take days. For this simple example, 8 is more than sufficient, since there are not enought node visits to reach 10$^\wedge$8 anyway\+: \begin{DoxyVerb}# The order of magnitude of the number of nodes explored during the depth-first search of the reaction trees procedure
mxndexplore 8
\end{DoxyVerb}


Finally, we have to determine how many trees we wish to print out. The best overall {\bfseries treesolutions} trees is given by\+: \begin{DoxyVerb}treesolutions 20
\end{DoxyVerb}


For this small system, 10 is sufficient. For much larger problems it is advised to print $\sim$100. As mentioned before, since we are lacking information of the energy barrier height of every pathway, it would be ill-\/advised to use the fitness (as defined above) as the only selective criteria. Instead, we can print the best {\bfseries evtreeprint} best trees from every cluster found in the final set, that is not already contained in the top {\bfseries treesolutions} set\+: \begin{DoxyVerb}#  print 10 molecules per eigenvector cluster found in the final tree set
evtreeprint 5
\end{DoxyVerb}


A Summary of all the parameters available are given at the bottom of this page. After running \char`\"{}cde.\+x input\char`\"{}, some progress report will be printed into the screen, and when finished we will have generated the following files\+: \begin{DoxyVerb}input_fullnet.gv
input_untrimmednet.gv
input_directednet.gv
input_nds.bin
input_p1/
input.log
\end{DoxyVerb}


The files ending in \char`\"{}.\+gv\char`\"{} and can be run using \char`\"{}dot -\/\+Tps N\+A\+M\+E.\+gv\char`\"{} to produce a postscript file to visualise the network. Note that for large networks this may take considerable amount of time, and its left to the users discretion. The graphs of the full Mol.\+dat connected network (to the reactants) is provided as \char`\"{}input\+\_\+fullnet.\+gv\char`\"{}, the graph of the same network with the direction arrows suggesting the possible ways the system could take is given by \char`\"{}input\+\_\+untrimmednet.\+gv\char`\"{} and finally, the most useful one, the network of directed nodes that have no dead ends or redundancies is given by \char`\"{}input\+\_\+directednet.\+gv\char`\"{}. Note with the latter, one should be able to follow the arrows from the products all the way to reactants without dead ends.

In the directory \char`\"{}input\+\_\+p1/\char`\"{} (note that if there were more than one products, we would obtain input\+\_\+p2, input\+\_\+p3....etc), one finds\+: \begin{DoxyVerb}btree_t1.ps
btree_t2.ps
   .
   .
   .
btree_t10.ps
evdir_1
evdir_2
   .
   .
evdir_5
btrees.dat
    hist.sh        
\end{DoxyVerb}


The file btrees.\+dat contains information on the molecules and reactions present for each one of the overall best trees, as well as for each cluster The top of the file reads\+: \begin{DoxyVerb}#####BEST### Tree ranked:     1, Id =     1, fitness fn =     0.18461 EvClust =    11 Members =     3
            -Reactions
            -- Rx    30 input_0000035.xyz
            -- Rx    72 input_0000086.xyz
            -- Rx    54 input_0000064.xyz
            -Molecules
            -- O2C1(    9)
            -- Pt9O3C1(   24)
            -- Pt9O2(   20)
            -- Pt9(    1)
            -- O2(    2)
            -- O1C1(    5)
#####BEST### Tree ranked:     2, Id =     2, fitness fn =     0.18461 EvClust =     1 Members =    30
            -Reactions
            -- Rx   110 input_0000132.xyz
            -- Rx    76 input_0000090.xyz
            -- Rx     1 input_0000001.xyz
            -- Rx     1 input_0000059.xyz
            -Molecules
            -- O2C1(    9)
            -- Pt9O2(   20)
\end{DoxyVerb}


The tree title lines belonging to the best trees set are prefixed by \char`\"{}\#\#\#\#\#\+B\+E\+S\+T\#\#\#\char`\"{}. The ranking is printed in the title line, as well as the Id of the tree, the fitness (the lower the value, the better -\/ less overall reaction energy change), to which cluster the molecule belongs to, and how many members that cluster has. The -\/\+Reactions list has the reaction Ids of the tree, and the reactionpaths associated with that Id. Reaction ID 30 in the network only has one G\+DS path input\+\_\+0000035.\+xyz. Notice that for the second best tree, reaction 1 has two paths associated with it (G\+DS found two plausible pathways that connect those reactants and products). The -\/\+Molecules list shows which molecules are present in the tree, with their ID in brackets. Further down the file, we find the top {\bfseries evtreeprint} clusters (of as many closest to that, the algorithm may have found)\+: \begin{DoxyVerb}##### EigenVector Cluster Rank:     1, members =      3
#####    1## Tree ranked:     1, Id =    21, fitness fn =     0.57985
            -Reactions
            -- Rx    30 input_0000035.xyz
            -- Rx    72 input_0000086.xyz
            -- Rx    76 input_0000090.xyz
            -- Rx     2 input_0000002.xyz
            -- Rx    29 input_0000033.xyz
            -- Rx    43 input_0000048.xyz
            -- Rx    43 input_0000098.xyz
            -- Rx    46 input_0000054.xyz
            -- Rx    47 input_0000055.xyz
            -Molecules
            - O2C1(    9)
            - Pt9O3C1(   24)
            - Pt9O2(   20)
\end{DoxyVerb}


Each set of best clusters begins with the line \char`\"{}\#\#\#\#\# Eigen\+Vector Cluster Rank\+:\char`\"{}, with each tree belonging to this cluster set presented, beginning with \textquotesingle{}\#\#\#\#\# X\#\#\textquotesingle{}, where X is the cluster ID. The trees that belong to this cluster are then presented in the same format as the best trees. Notice that this Cluster (Id = 1) says it has 3 members, but it has only printed 1. This meands that the other two members must be part of the B\+E\+ST set. Also note that for this example, Reaction 43 also has associated two G\+DS pathways.

Finally, a script hist.\+sh, is also provided. if executed the script shows the frequency of apperances of each G\+DS path in the set of best trees, each cluster set and all\+: \begin{DoxyVerb}Best Histogram:
      2 input_0000024.xyz
      2 input_0000027.xyz
             .
             .
             .
      7 input_0000026.xyz
      9 input_0000064.xyz
     10 input_0000090.xyz
     11 input_0000001.xyz
     11 input_0000059.xyz
Histogram Cluster 1:
      1 input_0000002.xyz
      1 input_0000033.xyz
             .
             .
             .
Histogram Full: 
      1 input_0000057.xyz
      1 input_0000058.xyz
      1 input_0000063.xyz
             .
             .
             .
     17 input_0000048.xyz
     17 input_0000059.xyz
     17 input_0000090.xyz
     17 input_0000098.xyz
\end{DoxyVerb}


The frequency appears first and the identity of the reaction path G\+DS file next to it. This can allow us to see which reaction paths have been encountered numberous times in the different sets of best pathways, and can help us thus decide which paths to run N\+EB on, and discover the minimum reaction pathway. In this example, it turns out that there are 42 reaction paths that are relevant (out of the 100+ available) to this particular proccess, and less than 20 that appear in more than five times in all the pathways. ~\newline
 There are two additional parameters for use during restart calculations. For large networks, the calculation may take some modest amount of time. On occassions, stages A1-\/\+A3 can take enough time to make it worthwhile having a restart. Specifically, one might wish to modify {\bfseries maxtreepergen}, {\bfseries evtreeprint}, {\bfseries treesolutions}, {\bfseries enforcefullrx}, {\bfseries mxndexplore} or {\bfseries treefaven}, all pertienet to stage A4), in a later calculation. Notice a file called \char`\"{}input\+\_\+nds.\+bin\char`\"{} was generated durin the first calculation, the keyword to use this binary file for a restart is then\+: \begin{DoxyVerb}readnds .true.
\end{DoxyVerb}


Note that if the nignore, rignore, prod, react parameters are changed in a restart, stages A1-\/\+A3 have to be redone. Finally, for big networks where a Depth-\/first search algorithm would visit significantly more than {\bfseries mxndexplore} nodes, a maximum sum of the absolute energy of every reaction in the branch history, {\bfseries absenthresh0}, during the D\+FS procedure is applied. This means that trees that might have branches (starting from the root product all the way to a leafs) whose sum of absolute energy for each reaction in that branch is greater than {\bfseries absenthresh0}, are blocked, for the sake of reducing the D\+FS algorithm to a size that is below {\bfseries mxndexplore}. During a first run, the average reaction energy change of the reactions available to the network, {\itshape avrx}, is calculated and an initial value for {\bfseries absenthresh0} is estimated as {\bfseries maxtreepergen} times {\itshape avrx}. This is typically a overestimate which will still lead to reducing the estimated {\bfseries absenthresh0} by 10\% each time, until the number of explored nodes lies below {\bfseries mxndexplore}. The logfile prints this information\+: \begin{DoxyVerb}**trees: Searching Product:     1
Estimating absenthresh, This may take some time. Current totndexp:         128
Increasing absenthresh: 0.06351 ...Current totndexp:         139
Increasing absenthresh: 0.07622 ...Current totndexp:         207
Increasing absenthresh: 0.09146 ...Current totndexp:         312
                    .
                    .
                    .
Increasing absenthresh: 1.81548 ...Current totndexp:    41651370
Increasing absenthresh: 1.97857 ...Current totndexp:    51867693
Increasing absenthresh: 2.17429 ...Current totndexp:    72049795
Increasing absenthresh: 2.40915 ...Current totndexp:    82106368
Increasing absenthresh: 2.69098 ...Current totndexp:    92109044
Increasing absenthresh: 2.99098 ...Current totndexp:   118120034
total number of nodes to visit =    92109044
\end{DoxyVerb}


For this example {\bfseries mxndexplore} is equal to 8 (10$^\wedge$8=10000000). Absenthresh is chosen as 2.\+69098 before we exceed this number. This example took seconds, but if {\bfseries mxndexplore} is greater than 9, it can take a significant amount of time. For restart calculations for this particular network, it is therefore recommended that one provides the {\bfseries absenthresh0} beforehand to skip this procedure, the keyword would then read\+: \begin{DoxyVerb}absenthresh0 2.7
\end{DoxyVerb}


Which would place it just under 10$^\wedge$8. ~\newline
 \#\+List of Graph\+Gen parameters\+:


\begin{DoxyItemize}
\item {\bfseries mxndexplore} \+:\+: The order of magnitude of the maximum total number of nodes explored during the tree graph search prodedure. a small number (will take seconds or minutes to finish) is 5 or 6. If 9 is chosen, with large treegencutoff, expect to wait days (and would recomment using treediskstore $\sim$ 0.\+15 if using large maxtreepergen).
\item {\bfseries treesolutions} \+:\+: For each of the user-\/given-\/products (Id of product from the \+\_\+\+Mol.\+dat file) given, it provides (in directory input-\/filename\+\_\+pX the top graphs (their fitness derived by integrating the absolute energy changes of each reaction present) found during a graphgen calculation on a G\+DS Molecular database \+\_\+\+Mol.\+dat.
\item {\bfseries treereactants} \+:\+: the starting reactants (Id from the \+\_\+\+Mol.\+dat file) that the user wishes to investigate for the best pathways (and obtain graphs) to the products provided in the treeproducts key (graphgen).
\item {\bfseries treeproducts} \+:\+: the end products (Id from the \+\_\+\+Mol.\+dat file) that the user wishes to investigate for the best pathways (and obtain graphs) from the reactants provided in the treereactants key (graphgen).
\item {\bfseries ignorereac} \+:\+: The Id of those reactions (Id from the \+\_\+\+Mol.\+dat file) that one wishes to discount from the reaction graph construction (graphgen)
\item {\bfseries ignoremol} \+:\+: The Id of those molecules (Id from the \+\_\+\+Mol.\+dat file) that one wishes to discount from the reaction graph construction (graphgen)
\item {\bfseries maxtreepergen} \+:\+: The possibilities of pathways grows combinatorially on every generation of the reaction trees, maxtreepergen dictates how many of the best trees (by their fitness defined by integrating the absolute energy changes of each reaction present) should be sent to the branch generation above it in the tree to be further combinatorially mixed.
\item {\bfseries treegencutoff} \+:\+: the maximum number of branch generations (branch=molecule with more than one reaction available) we are reaching during the exploration of reaction pathways. For simple systems 10 should be sufficient, for complicated, many multistep procceses 20 is probably the maximum limit. With 20 Generations of the trees for large networks the possibilities become very large, so expect waiting a while..
\item {\bfseries treediskstore} \+:\+: if a set of child branches has produced more than treediskstore$\ast$maxtreepergen trees, then store them on disk. For large networks with large maxtreepergen, we would suggest 0.\+1. For small systems that can store everything in memory, 1.\+0. Setting it to 0.\+0 will make the calculations extremely slow.
\item {\bfseries evtreeprint} \+:\+: As well as producting treesolutions best trees, it also clusters the final maxtreepergen trees (that it found at the end of the selective proccess) into different families and prints the top 50 for each (in this example) into a directory input-\/filename\+\_\+p\+X/evdir\+\_\+X
\item {\bfseries enforcefullrx} \+:\+: Enforces to print only trees with full set of reactants as leafs
\item {\bfseries treefaven} \+:\+: Enforces to print only those trees whose sum of all reactant leaves relative energies are positive (the reaction path is favourable) by setting 1, negative (unfavourable) -\/1, or neutral 0
\item {\bfseries mxndexplore} \+:\+: The order of magnitude of the maximum total number of nodes explored during the tree graph search prodedure. a small number (will take seconds or minutes to finish) is 5 or 6. If 9 is chosen, with large treegencutoff, expect to wait many hours (and would recomment using treediskstore $\sim$ 0.\+15 if using large maxtreepergen).
\item {\bfseries readnds} \+:\+: Weather or not this is a restart calculation for which we wish to use the \char`\"{}\+\_\+nds.\+bin\char`\"{} file to skip stages A1-\/\+A3). Note that if the nignore, rignore, prod, react parameters are changed in a restart, stages A1-\/\+A3 have to be redone.
\item {\bfseries absenthresh0} \+:\+: provide a maximum sum of the absolute energy of every reaction in the branch history H, used to cutoff the D\+FS algorithms to a managable size, used for restart calculations and estimated based on the information provided in the log file of the previous run. 
\end{DoxyItemize}